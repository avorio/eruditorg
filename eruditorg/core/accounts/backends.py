# -*- coding: utf-8 -*-

import crypt
import logging
import types

from django.conf import settings
from django.contrib.auth import get_user_model
from django.contrib.auth.backends import ModelBackend
from django.core.exceptions import ValidationError
from django.core.validators import validate_email

from .utils.mandragore import get_user_from_mandragore
from .utils.mandragore import update_user_password

logger = logging.getLogger(__name__)


class EmailBackend(ModelBackend):
    """ Allows a user to login using his e-mail address or his username.

    This backend should be used instead of the builtin `django.contrib.auth.backends.ModelBackend`
    authentication backend.
    """
    def _get_user(self, email_or_username):
        UserModel = get_user_model()

        # Tries to fetch the user instance using the e-mail address or the username
        try:
            try:
                validate_email(email_or_username)
                user = UserModel.objects.get(email=email_or_username.lower())
            except UserModel.MultipleObjectsReturned:
                logger.warning(
                    'Unable to authenticate {} because many users have '
                    'the same e-mail address'.format(email_or_username), exc_info=True)
                raise UserModel.DoesNotExist
            except ValidationError:
                user = UserModel.objects.get(username=email_or_username)
        except UserModel.DoesNotExist:
            return

        return user

    def authenticate(self, username=None, password=None, **kwargs):
        user = self._get_user(username)
        if user and user.check_password(password):
            return user


def set_password_mandragore(self, raw_password):
    """ Set the password in Mandragore

    This method is meant to replace the default set_password
    method of :py:class:`django.contrib.auth.models.User`

    Uses :py:func:`crypt.crypt` to generate a ``SHA512`` hash of
    raw_password. raw_password is salted with a random salt
    generated by :py:func:`crypt.mksalt`.
    """

    # Use only 8 characters in the salt. Otherwise the generated hash will be
    # to long for the mandragore MotDePasse Field.
    the_hash = crypt.crypt(
        raw_password,
        salt=crypt.mksalt(
            method=crypt.METHOD_SHA512
        )[:11]
    )

    update_user_password(self.username, the_hash)
    self.save()


class MandragoreBackend(ModelBackend):
    """ Authenticate users against the Mandragore database

    Monkeypatches django.contrib.auth.models.User to replace `set_password` with
    :py:func:`set_password_mandragore`
    """

    def authenticate(self, username=None, password=None):

        User = get_user_model()

        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist:
            return

        # Being connected to the "Mandragore" database is not
        # mandatory. Thus we do not raise `PermissionDenied` but
        # let Django try to authenticate the user with the ModelBackend.
        if ((not hasattr(settings, 'EXTERNAL_DATABASES') or
             type(settings.EXTERNAL_DATABASES) != dict or
             'mandragore' not in settings.EXTERNAL_DATABASES)):
            return None

        mand_user, mand_pw = get_user_from_mandragore(username)

        _, algo, salt, hashed_pass = mand_pw.split('$')

        user_pass = crypt.crypt(
            password, '${}${}'.format(
                algo,
                salt,
            )
        )

        if user_pass == mand_pw:
            user.set_password = types.MethodType(set_password_mandragore, user)
            return user
